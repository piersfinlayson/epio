#!/usr/bin/env python3
#
# Copyright (C) 2026 Piers Finlayson <piers@piers.rocks>
#
# MIT License
#
# gen_epio_js.py - Generate epio cwrap bindings and reference HTML from epio.h
#
# Usage: python3 gen_epio_js.py <path/to/epio.h> <output/epio_bindings.js> <output/index.html>
#

import re
import sys
import os

# Map from C types to Emscripten cwrap type strings.
# Pointers (anything ending with *) are handled separately as 'number'.
C_TYPE_MAP = {
    'void':     None,
    'uint8_t':  'number',
    'uint16_t': 'number',
    'uint32_t': 'number',
    'int32_t':  'number',
    'int':      'number',
    'size_t':   'number',
    'uint64_t': 'bigint',
}

def map_type(c_type: str) -> str | None:
    """Map a C type string to an Emscripten cwrap type string."""
    c_type = c_type.strip()
    if c_type.endswith('*'):
        return 'number'
    result = C_TYPE_MAP.get(c_type)
    if result is None and c_type != 'void':
        return 'number'  # assume opaque struct pointer
    if c_type == 'void':
        return None
    return result

def parse_exports(header_text: str) -> list[dict]:
    """
    Parse EPIO_EXPORT function declarations from the header.
    Each function dict contains:
      name     - function name
      ret      - cwrap return type string (or None for void)
      ret_c    - original C return type string (for display)
      args     - list of cwrap type strings for parameters
      params   - list of (c_type_str, param_name) for display
    """
    text = re.sub(r'/\*.*?\*/', '', header_text, flags=re.DOTALL)
    text = re.sub(r'//[^\n]*', '', text)

    pattern = re.compile(
        r'EPIO_EXPORT\s+'
        r'([\w\s]+?)\s*(\*?)\s*'  # return type + optional *
        r'(\w+)\s*'               # function name
        r'\(([^)]*)\)\s*;',       # parameter list
        re.MULTILINE
    )

    functions = []
    for m in pattern.finditer(text):
        ret_base   = m.group(1).strip()
        ret_star   = m.group(2).strip()
        name       = m.group(3).strip()
        params_raw = m.group(4).strip()

        ret_c    = ret_base + (' *' if ret_star else '')
        ret_type = map_type(ret_c)

        args   = []
        params = []
        if params_raw and params_raw != 'void':
            for param in params_raw.split(','):
                param = param.strip()
                if not param:
                    continue
                param = re.sub(r'\s*\*\s*(\w+)$', r'* \1', param)
                tokens = param.rsplit(None, 1)
                c_type = tokens[0].strip() if len(tokens) > 1 else tokens[0]
                p_name = tokens[1].strip() if len(tokens) > 1 else ''
                args.append(map_type(c_type))
                params.append((c_type, p_name))

        functions.append({
            'name':   name,
            'ret':    ret_type,
            'ret_c':  ret_c,
            'args':   args,
            'params': params,
        })

    return functions

def js_type(t) -> str:
    if t is None:
        return 'null'
    return f"'{t}'"

def generate_js(functions: list[dict]) -> str:
    lines = [
        "// Auto-generated by gen_epio_js.py - do not edit by hand.",
        "// Copyright (C) 2026 Piers Finlayson <piers@piers.rocks>",
        "// MIT License",
        "",
        "// Emscripten places the module in the global 'Module' object after WASM is",
        "// loaded.  We wait for the 'onRuntimeInitialized' callback before binding.",
        "",
        "var epio = {};",
        "",
        "Module['onRuntimeInitialized'] = function() {",
    ]
    for fn in functions:
        ret_str  = js_type(fn['ret'])
        args_str = ', '.join(js_type(a) for a in fn['args'])
        lines.append(
            f"    epio.{fn['name']} = Module.cwrap("
            f"'{fn['name']}', {ret_str}, [{args_str}]);"
        )
    lines += ["};", ""]
    return "\n".join(lines)

def c_sig(fn: dict) -> str:
    """Reconstruct a C-style function signature using the original C types."""
    ret = fn['ret_c'] or 'void'
    params = ', '.join(
        f"{ct} {pn}".strip() for ct, pn in fn['params']
    ) or 'void'
    return f"{ret} {fn['name']}({params})"

def js_sig(fn: dict) -> str:
    """Show the JS call signature using cwrap types."""
    args = ', '.join(
        f"{pn}: {js_type(at)}" if pn else js_type(at)
        for (_, pn), at in zip(fn['params'], fn['args'])
    ) or ''
    return f"epio.{fn['name']}({args}) → {js_type(fn['ret'])}"

def generate_html(functions: list[dict], js_path: str) -> str:
    js_filename = os.path.basename(js_path)
    rows = "\n".join(
        f"  <tr>"
        f"<td><code>{fn['name']}</code></td>"
        f"<td><code>{c_sig(fn)}</code></td>"
        f"<td><code>{js_sig(fn)}</code></td>"
        f"</tr>"
        for fn in functions
    )
    return f"""<!DOCTYPE html>
<!-- Auto-generated by gen_epio_js.py - do not edit by hand. -->
<!-- Copyright (C) 2026 Piers Finlayson <piers@piers.rocks> -->
<!-- MIT License -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>epio WASM</title>
  <style>
    body {{ font-family: sans-serif; max-width: 1100px; margin: 2em auto; padding: 0 1em; }}
    h1   {{ font-size: 1.4em; }}
    p    {{ color: #444; }}
    table {{ border-collapse: collapse; width: 100%; font-size: 0.88em; }}
    th   {{ text-align: left; background: #f0f0f0; padding: 0.4em 0.6em; border: 1px solid #ccc; }}
    td   {{ padding: 0.35em 0.6em; border: 1px solid #ddd; vertical-align: top; }}
    tr:nth-child(even) {{ background: #fafafa; }}
    code {{ font-size: 0.95em; }}
  </style>
</head>
<body>
  <h1>epio WASM — API Reference</h1>
  <p>
    Load <code>epio.js</code> (Emscripten glue) and <code>{js_filename}</code>
    (generated cwrap bindings) to use the <code>epio</code> object in the browser console.
  </p>
  <table>
    <thead>
      <tr><th>Function</th><th>C signature</th><th>JS binding</th></tr>
    </thead>
    <tbody>
{rows}
    </tbody>
  </table>

  <script src="epio.js"></script>
  <script src="{js_filename}"></script>
</body>
</html>
"""

def main():
    if len(sys.argv) != 4:
        print(f"Usage: {sys.argv[0]} <epio.h> <epio_bindings.js> <index.html>", file=sys.stderr)
        sys.exit(1)

    header_path = sys.argv[1]
    js_path     = sys.argv[2]
    html_path   = sys.argv[3]

    with open(header_path, 'r') as f:
        header_text = f.read()

    functions = parse_exports(header_text)
    if not functions:
        print("Warning: no EPIO_EXPORT functions found.", file=sys.stderr)

    with open(js_path, 'w') as f:
        f.write(generate_js(functions))
    print(f"Generated {len(functions)} bindings → {js_path}")

    with open(html_path, 'w') as f:
        f.write(generate_html(functions, js_path))
    print(f"Generated reference page   → {html_path}")

if __name__ == '__main__':
    main()